/*

This program allows the recording and plotting of a logic level serial
data stream somewhat akin to a logic analyzer. A minimum of hardware
is required to implement. I wrote this program to analyze the serial
data stream generated by a VCR's wireless remote.

The parallel printer port 'Acknowledge' line is used to generate
interrupts at the corresponding edges of the signal, while the
timer chip in the PC is used to obtain the time of the transition
of the signal.


Hardware Requirements:

 1 )  Radio Shack Infrared Receiver / Demodulator.   ( $4 )

       This simple module provides amplification and demodulation
       of the infrared signal to a 5 volt logic level.

	   Pin #1      Signal Output
	   Pin #2      VCC +5 Volts
	   Pin #3      Ground


 2 )  Small toride.  ( $ ? )

        The 3 wires from the Infrared module should be wound a
        couple of times around this toride to eliminate interference
        problems. The module is susceptible to magnetic fields despite
        what the technical data sheet says.


 3 )  74LS86  exclusive or gate.   ( $ 1.0 )

		This gate is used as a programmable inverter so that both
        negative and positive edges of signal can generate interrupts.

        One input to the gate comes from the IR module output signal
        and the other is driven by the strobe line of the printer port.

        A 4.7K pull-up resister ( pull-up to +5 volts ) must tied at
        the gate to the 'strobe line' for termination and balance of
        the line.


Connections:

Printer Port

  Pin #1   'Strobe Output'   -->   Pin #12 74LS86  (Input )
  Pin #10  'Ack Input'       -->   Pin #11 74LS86  (Output)
  Pin #25                    -->   Gnd


  74LS86   Pin # 14 --> +5 volts
           Pin # 7  --> Gnd
		   Pin # 13 --> IR module Pin #1


  E. A. Sicard   CIS  70701,1234
*/


#include "stdio.h"
#include "conio.h"
#include "dos.h"
#include "graphics.h"
#include "stdlib.h"
#include "bios.h"

/*  External Assembly Language Routines */

unsigned long readtimer( void );
void initializetimer(void);
void restoretimer(void);

/*   Keyboard Stuff  */

#define ESC		0x1B
#define F1  	0x3B
#define F2  	0x3C
#define RSHIFT 	0x4D
#define LSHIFT 	0x4B


#define out     outportb
#define in      inportb

#define TRUE	1			/* Define some handy constants	*/
#define FALSE	0			/* Define some handy constants	*/
#define ON		1			/* Define some handy constants	*/
#define OFF		0			/* Define some handy constants	*/


/* Printer ports */

#define DPORT 0x378     /* Data port    (output) */
#define SPORT 0x379     /* Status port  (input)  */
#define CPORT 0x37A     /* Control port (output) */

/*  Interrupt Vector  */

#define PARALLEL_INT 0x0F

/* Timer Definitions */

#define TimerResolution    1193181.667


FILE *fp;

int    GraphDriver;			/* The Graphics device driver			*/
int    GraphMode;			/* The Graphics mode value				*/
double AspectRatio;			/* Aspect ratio of a pixel on the screen*/
int    MaxX, MaxY;			/* The maximum resolution of the screen */
int    MaxColors;			/* The maximum # of colors available	*/
int    ErrorCode;			/* Reports any graphics errors			*/
struct palettetype palette;	/* Used to read palette info			*/

/*  Current Time Base  */

unsigned long TimeBase = 70000;


/*  Used by interrupt routine only  */

unsigned long last, stamp;
int start;

/*  Buffer and buffer pointers  */

unsigned long buffer[1000];
unsigned long *b_ptr;

/*  Interrupt Prototye declaration  */

static void interrupt (*oldvect)();


/*
**  Parallel Port Interrupt Service Routine...
*/

void interrupt parallel_isr( void ) {

   disable();
   if ( start ) {               /* Check if this is Start */
      last = readtimer();       /* Yes. Get time Stamp    */
      start = 0;          	/* Clear Start flag	  */
   }
   else {                       /* Not started            */
      stamp = readtimer();	/* Get time Stamp	  */
      *b_ptr++ = stamp - last;  /* Compute Differance     */
      last = stamp;
   }
   out(CPORT,(in(CPORT)^1));	/* Change int polarity    */
   out(0x20,0x20);              /* Send 'eoi' signal to   */
   enable();
}




static void changetextstyle( int font, int direction, int charsize ) {
  int ErrorCode;
  graphresult();                            /* clear error code         */
  settextstyle(font, direction, charsize);
  ErrorCode = graphresult();                /* check result             */
  if( ErrorCode != grOk ){                  /* if error occured         */
    closegraph();
    printf(" Graphics System Error: %s\n", grapherrormsg( ErrorCode ) );
    exit( 1 );
  }
}


static void DrawBorder( void ) {
  struct viewporttype vp;
  setcolor( MaxColors - 1 );                /* Set color to white       */
  setlinestyle( SOLID_LINE, 0, NORM_WIDTH );
  getviewsettings( &vp );
  rectangle( 0, 0, vp.right-vp.left, vp.bottom-vp.top );
}


static void StatusLine( char *msg ) {
  int height;

  setviewport( 0, 0, MaxX, MaxY, 1 );       /* Open port to full screen     */
  setcolor( MaxColors - 1 );                /* Set color to white           */

  changetextstyle( DEFAULT_FONT, HORIZ_DIR, 1 );
  settextjustify( CENTER_TEXT, TOP_TEXT );
  setlinestyle( SOLID_LINE, 0, NORM_WIDTH );
  setfillstyle( EMPTY_FILL, 0 );

  height = textheight( "H" );           /* Detemine current height      */
  bar( 0, MaxY-(height+4), MaxX, MaxY );
  rectangle( 0, MaxY-(height+4), MaxX, MaxY );
  outtextxy( MaxX/2, MaxY-(height+2), msg );
  setviewport( 1, height+5, MaxX-1, MaxY-(height+5), 1 );
}



static void Initialize( void ) {
  int xasp, yasp;						/* Used to read the aspect ratio*/

  GraphDriver = DETECT; 				/* Request auto-detection		*/
  initgraph( &GraphDriver, &GraphMode, "" );
  ErrorCode = graphresult();			/* Result of initialization		*/
  if( ErrorCode != grOk ){				/* Error occured during init	*/
    printf(" Graphics System Error: %s\n", grapherrormsg( ErrorCode ) );
    exit( 1 );
  }

  getpalette( &palette );				/* Read the palette from board	*/
  MaxColors = getmaxcolor() + 1;		/* Read maximum number of colors*/

  MaxX = getmaxx();
  MaxY = getmaxy();						/* Read size of screen			*/

  getaspectratio( &xasp, &yasp );				/* read the hardware aspect	*/
  AspectRatio = (double)xasp / (double)yasp; 	/* Get correction factor	*/
}




static void MainWindow( char *header ) {
  int height;
  cleardevice();						/* Clear graphics screen		*/
  setcolor( MaxColors - 1 );			/* Set current color to white	*/
  setviewport( 0, 0, MaxX, MaxY, 1 );	/* Open port to full screen		*/
  height = textheight( "H" );           /* Get basic text height        */
  changetextstyle( DEFAULT_FONT, HORIZ_DIR, 1 );
  settextjustify( CENTER_TEXT, TOP_TEXT );
  outtextxy( MaxX/2, 2, header );
  setviewport( 0, height+4, MaxX, MaxY-(height+4), 1 );
  DrawBorder();
  setviewport( 1, height+5, MaxX-1, MaxY-(height+5), 1 );
}


static void PlotSerial( void ) {
	char	buf[32];			int 	ch, start, xstep, ystep;
	int		sheight, swidth;	int 	i, j, h, llogic;
	struct 	viewporttype vp;	float 	PixelPerBase;
    unsigned long *p;

	MainWindow( "S e r i a l    T i m e    P l o t" );

	start = 0;
	while(1) {
		h = 3 * textheight( "H" );
		getviewsettings( &vp );
		setviewport( vp.left+4, vp.top+30, vp.right-4, vp.bottom-10, 1 );
		getviewsettings( &vp );
		sheight = vp.bottom - vp.top;
		swidth  = vp.right  - vp.left;

		PixelPerBase = (float) swidth / (float) TimeBase;

		line( h, sheight-h, swidth-h, sheight-h );   /* X - axis */
		ystep = (sheight - (2*h) ) / 20;
		xstep = (swidth  - (2*h) ) / 10;

		j = h;
		for ( i=0 ; i<11 ; ++i ) {                  /* Do horizontal axis */
			line( j, sheight - h, j, sheight- 3 - (h/2) );
			j += xstep;
		}
		j = h;										/* Start postion on screen */
		setfillstyle( 1,4 );

		p = buffer;

		for ( i = start; j < swidth ; ++i ) {       /* Do horizontal axis */
			if ( *p == 0 ) {
				break;
			}
			else {
				bar( j, (sheight-h)-((i & 1) * ystep), j+( *p * PixelPerBase), sheight-h-1 );
				rectangle( j, (sheight-h)-((i & 1) * ystep), j+( *p * PixelPerBase), sheight-h   );
			}
			j = j + *p * PixelPerBase;
			p++;
		}


		StatusLine( "<ESC> Exit   <F1> TimeBaseInc   <F2> TimeBaseDec");
		settextjustify( LEFT_TEXT, TOP_TEXT );
		outtextxy( vp.left + 40, vp.top, "Time Base : " );
		outtextxy( vp.left + 40 + ( textwidth("H") * 13 ), vp.top, ltoa(( long ) TimeBase, buf, 10 ));

		ch = getch();
		if (ch == ESC) break;
		if (ch == F1)  TimeBase = TimeBase + 10000;
		if ((ch == F2) &&  (TimeBase > 10000) ) TimeBase = TimeBase - 10000;
		clearviewport();
	}
}

static void main1( void ) {
    int i;
	Initialize();
	PlotSerial();
	closegraph();
}


static void go( void ) {

   unsigned long x;

/*
   bioscom( 0, 0x80 | 0x03, 0 );
*/
   for ( x = 0; x < sizeof(buffer) / sizeof(buffer[0]) ; x++)
      buffer[x] = 0L;                     /*  Get buffer limit */

   printf("\n\n\nRunning...\n");
   start = 1;                              /* Set start flag */
   b_ptr = buffer;                         /* Set record buffer */

   disable();
   oldvect = getvect( PARALLEL_INT );
   setvect( PARALLEL_INT, parallel_isr );  /* Set interrupt vector */
   out(CPORT,0x3C);                        /* Start with int om, and not int level */
   out( 0x21, ( in( 0x21 ) & 0x7F ));    	/* enable IRQ7 */
   enable();

/* Next two for testing only */
/*
   while( bioscom(3,0,0) & 0x2000  == 0 );
   bioscom(1,0x55,0);
*/

   while( ! kbhit() );                     /* Do nothing until */

   out(CPORT,(in(CPORT)^1));
   delay(1000);
   *b_ptr = 0;

   disable();
   out(0x21,(in(0x21) | 0x80));      		/* disable IRQ7 */
   setvect(PARALLEL_INT,oldvect);
   enable();

}

static void dohelp( void ) {
	puts("\n\n\n");
	puts("      G  =  Record Infared Signal");
	puts("      D  =  Dump Recorded Signal to Screen");
	puts("      P  =  Plot Recorded Signal to Screen");
	puts("      M  =  Display Min/Max Pulse Times");
	puts("      S  =  Display Port Status Lines");
	puts("      C  =  Test Serial Send");
	puts("      L  =  Toggel Strobe Line");
	puts("      F  =  Write Recorded Signal to File");
	puts("      Q  =  Quit\n");
	printf(" Command -> ");
}

main( )  {
	char tbuf[128];
	int count,i,llogic;
	unsigned long *p;
	unsigned long itime,min,max,ch;
	int x,y,lh;

    out(CPORT,0x3C);        /* Preset programmable invert signal */

	while(1) {
		clrscr();
		dohelp();
		ch = getche();
		switch ( ch ) {
			case 'g':;
            case 'G':;
                    initializetimer();
                    go();
                    restoretimer();
                    break;
			case 'd':;
			case 'D':;
				llogic = 0;
				for ( p = buffer; p < b_ptr-1;  )  {
					printf("\n %d  %f ", llogic, *p++ * ( 1 / TimerResolution ));
					llogic = llogic ^ 1;
				}
				getch(); break;
			case 'f':;
			case 'F':;
				puts("\nEnter Message to put in flie..");
				gets(tbuf);
				if ( (fp = fopen("dump.doc","at")) != 0 ) {
					fputs("\n\n", fp);
					fputs( tbuf,fp);
					fputs("\n\n", fp);
					llogic = 0;
					for ( p = buffer; p < b_ptr-1;  )  {
						fprintf(fp,"\n %d %f ", llogic, *p++ * ( 1 / TimerResolution ));
                        llogic = llogic ^ 1;
					}
					fclose(fp);
				}
				break;
			case 'm':;
			case 'M':;
				min = 0xffffffff; max = 0;
				for ( p = buffer; p < b_ptr; p++ )  {
					if ( *p > max ) max = *p;
					if ( *p < min ) min = *p;
				}
				puts("\n");
				printf("\n       Maximum = %f  ", max * ( 1 / TimerResolution ));
				printf("\n       Minimum = %f\n", min * ( 1 / TimerResolution ));
				puts  ("\n       Press A Key...");
				getch();
				break;
			case 'q':;
			case 'Q':;
				exit(0);
			case 'p':;
			case 'P':;
				main1();
				break;
			case 's':;
			case 'S':;
				clrscr();
                printf("\nInterrupt (ack)  = %d", ( in(SPORT) & 0x40) >> 6);
                printf("\nStrobe           = %d", in(CPORT) & 1);
                printf("\nIR Level         = %d", ( in(SPORT) & 0x80 ) >> 7);
				printf("\n\n Press a Key...");
				getch();
				break;
			case 'l':;
			case 'L':;
                out(CPORT, (in(CPORT) ^1)) ;
				break;
			default:;
		}
	}
}


